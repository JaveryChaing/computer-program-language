## Oracle 体系结构

#### **JDBC连接方式**

> service_name连接方式：jdbc:oracle:thin:@//<host>:<port>/<service_name>
>
> > ~~~sql
> > -- 服务名称，一个数据库可以拥有多个实例（集群），其service_names是唯一的
> > select value from v$parameter where name=‘service_names’;
> > ~~~
>
> SID连接方式：jdbc:oracle:thin:@<host>:<port>:<SID>
>
> > ~~~sql
> > -- 实例名称，响应某个数据库操作的数据库管理系统的名称 
> > select value from v$parameter where name=‘instance_name’;
> > ~~~
>
> TNSName连接方式：jdbc:oracle:thin:@<TNSName>
>
> > tnsnames.ora
> >
> > ~~~json
> > # tnsnames.ora Network Configuration File: /opt/oracle/product/19c/dbhome_1/network/admin/tnsnames.ora
> > # Generated by Oracle configuration tools.
> > 
> > LISTENER_ORCL =
> >   (ADDRESS = (PROTOCOL = TCP)(HOST = xbf)(PORT = 1521))
> > 
> > 
> > cdb19c =
> >   (DESCRIPTION =
> >     (ADDRESS = (PROTOCOL = TCP)(HOST = miaomiaole.xyz )(PORT = 7004))
> >     (CONNECT_DATA =
> >       (SERVER = DEDICATED)
> >       (SERVICE_NAME = ORCL)
> >     )
> >   )
> >   
> > pdb19c =
> >   (DESCRIPTION =
> >     (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.31.106 )(PORT = 1521))
> >     (CONNECT_DATA =
> >       (SERVER = DEDICATED)
> >       (SERVICE_NAME = ORCLPDB)
> >     )
> >   )
> > 
> > cdb12c =
> >   (DESCRIPTION =
> >     (ADDRESS = (PROTOCOL = TCP)(HOST = miaomiaole.xyz )(PORT = 7005))
> >     (CONNECT_DATA =
> >       (SERVER = DEDICATED)
> >       (SERVICE_NAME = ORCL)
> >     )
> >   )
> > ~~~
>
> URL only连接方式 jdbc:oracle:thin:@ip:port/DATABASENAME

#### **Oracle结构**

> - **实例（Oracle Instance）**
>
>   > Oracle12及以上版本一个实例可以运行多个数据库。
>   >
>   > ~~~sql
>   > sqlplus / as sysdba
>   > -- 实例启动
>   > startup;
>   > -- oracle 端口监听启动
>   > lsnrctl start
>   > ~~~
>
> - **数据库（DataBase）**
>
>   > 基于磁盘的数据文件、控制文件、日志文件、参数文件和归档日志文件等组成的物理文件集合
>   >
>   > **CDB：数据库容器**
>   >
>   > **PDB：可插拔数据库**
>   >
>   > ~~~sql
>   > -- 查看当前是否处于容器CDB
>   > show con_name;
>   > -- 查看pdbs容器中的数据库名
>   > show pdbs;
>   > -- 切换当前登录会话（切换数据库）、启动PDB数据库
>   > alter session set container=ORCLPDB
>   > -- 启动PDB数据库
>   > alter pluggable database PDBEPPS open;
>   > -- g关闭PDB数据库
>   > alter pluggable database PDBEPPS close;
>   > -- 切换到CDB  （CDB中的用户必须以C##开头）
>   > alter session set container=CDB&ROOT
>   > ~~~
>
> **物理结构**
>
> > ~~~sql
> > -- 查看Oracle 文件存储位置
> > show parameter dump;
> > ~~~
> >
> > 数据文件（dbf,ora），一个表空间存在多个数据文件，一个数据文件只属于某个表空间
> >
> > 日志文件（trc，log），包含报价日志，跟踪用户进程日志，redo log重做日志
> >
> > 控制文件
> >
> > 参数文件
>
> **逻辑结构**
>
> - 表空间（tablespaces）：数据库包含多个表空间，表空间时数据库恢复的最小单位。包含表，视图，索引，聚簇、回退段和临时段
>
>   > ~~~sql
>   > -- 查看表空间
>   > select * from v$tablespace;
>   > -- 查看表空间文件
>   > desc dba_data_files;
>   > -- 查看详细数据文件
>   > select file_name,tablespace_name from dba_data_files;
>   > -- 创建表空间 Oracle数据文件上限32G，表空间设置容量与块大小有关，BLOCK_SIZE * 4194304 = tablespace
>   > -- 4k最大表空间为：16384M=16G
>   > -- 8K最大表空间为：32768M=32G
>   > -- 16k最大表空间为：65536M=64G
>   > create tablespace paul datafile '/ora10/product/oradata/ora10/paul01.dbf' size 20m;
>   > -- 查看表空间大小
>   > SELECT a.tablespace_name "表空间名",
>   >        a.bytes / 1024 / 1024 "表空间大小(M)",
>   >        (a.bytes - b.bytes) / 1024 / 1024 "已使用空间(M)",
>   >        b.bytes / 1024 / 1024 "空闲空间(M)",
>   >        round(((a.bytes - b.bytes) / a.bytes) * 100, 2) "使用比"
>   > FROM (SELECT tablespace_name, sum(bytes) bytes
>   >       FROM dba_data_files
>   >       GROUP BY tablespace_name) a,
>   >      (SELECT tablespace_name, sum(bytes) bytes, max(bytes) largest
>   >       FROM dba_free_space
>   >       GROUP BY tablespace_name) b
>   > WHERE a.tablespace_name = b.tablespace_name
>   > ORDER BY ((a.bytes - b.bytes) / a.bytes) DESC
>   > -- 查看表空间是否自动扩展
>   > SELECT file_id, file_name, tablespace_name, autoextensible, increment_by
>   >  
>   > FROM dba_data_files
>   >  
>   > WHERE tablespace_name = '表空间名称'
>   >  
>   > ORDER BY file_id desc;
>   > -- 修改文件大小
>   > alter database datafile '全路径的数据文件名称' resize ***M;
>   > -- 增加文件数量
>   > alter tablespace 表空间名称 add datafile '全路径的数据文件名称' size ***M
>   >  autoextend on maxsize 20G;
>   > ~~~
>
> - 段（segment）：占用数据文件空间的通称，或数据库对象使用的空间的集合；段可以有表段、索引段、回滚段、临时段和高速缓存段等。
>
>   > ~~~sql
>   > -- 查看段的类型
>   > select distinct segment_type from dba_segments;
>   > ~~~
>   >
>   > - TABLE：普通表数据结构
>   > - INDEX：表普通索引
>   > - CLUSTER：游标，可以存储多个表）
>   > - LOBINDEX：
>   >
>   > ...
>
> - 区间（Extent）
>
>   > 记入分配对象的连续逻辑地址，多个区间组成一个段。
>
> - 数据块（Block）
>
>   > Oracle系统在创建表空间时将数据文件格式化成若干个Oracle块；每个Oracle块是Oracle系统处理的最小单位；
>
>   逻辑结构：<img src="img\image-20230225221235090.png" alt="image-20230225221235090" style="zoom:67%;" /> 
>
> **内存结构**
>
> - 共享池
> - 数据缓冲区
> - 日志缓冲区
> - PGA：一个进程和线程专用的内存，分为私有SQL区域，会话空间，SQL工作区
> - SGA：一个数据库实例的数据和控制信息的共享内存结构
>
>   内存结构：<img src="img\image-20230225221441971.png" alt="image-20230225221441971" style="zoom:67%;" /> 
>
>   
>
> **进程**
>
> - 用户进程
>
>   ~~~sql
>   -- 查看进程数
>   select count(*) from v$process;
>   -- 查看当前会话数
>   select count(*) from v$session;
>   -- 查看当前并发数
>   select count(*) from v$session where status='ACTIVE';
>   -- 修改连接
>   alter system set processes = value scope = spfile
>   -- 修改数据库最大连接数
>   alter system set processes = 300 scope = spfile;
>   -- 释放连接会话
>   alter system kill session 'sid, serial#'
>   -- 查看占用系统 io 较大的 session
>   SELECT se.sid,se.serial#,pr.SPID,se.username,se.status,se.terminal,se.program,se.MODULE,se.sql_address,st.event,st.p1text,si.physical_reads,si.block_changes
>
>   　　FROM v$session se,　v$session_wait st,v$sess_io si,v$process pr
>
>   　　WHERE st.sid=se.sid　AND st.sid=si.sid AND se.PADDR=pr.ADDR AND se.sid>6　AND st.wait_time=0 AND st.event NOT LIKE '%SQL%' ORDER BY physical_reads DESC
>   -- 找出耗 cpu 较多的 session
>   select a.sid,spid,status,substr(a.program,1,40) prog,a.terminal,osuser,value/60/100 value
>
>   　　from v$session a,v$process b,v$sesstat c
>
>   　　where c.statistic#=12 and c.sid=a.sid and a.paddr=b.addr order by value desc
>   ~~~
>
> - 后台进程
>
>   > PMON：进程监视器，处理异常连接
>   >
>   > SMON：故障恢复实例，清理临时文件
>   >
>   > DBWn：读写磁盘进程
>   >
>   > CKPT：脏写校验
>   >
>   > LGWR：日志线程
>   >
>   > ARCn：归档进程
>   >
>   > LREG：它使用Oracle Net Listener 在数据库实例和调度程序进程上注册信息。
>

#### **ORACLE 日志**

> redo也就是重做日志文件（redo log file）Oracle维护着两类重做日志文件：在线（online）重做日志文件和归档（archived）重做日志文件。这两类重做日志文件都用于恢复；其主要目的是，万一实例失败或介质失败，它们能够恢复数据。 由于数据库缓冲，对磁盘数据的更新不是实时的，但是对redo日志的更新会在commit之后确切发生。  如果在事务提交之后，磁盘数据更新之前，系统发生故障，比如断电，系统重启之后会将那些已经写入redo
>
> undo对数据执行修改时，数据库会生成undo信息，这样万一你执行的事务或语句由于某种原因失败了，或者如果你用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据放回到修改前的样子。redo用于在失败时重放事务（即恢复事务），undo则用于取消一条语句或一组语句的作用
>
> https://www.cnblogs.com/linux-186/p/13814338.html

#### **Oracle 对象**

> - #### **表（Table）**
>
>   > Oracle表中字段可以是用户自定义的对象类型，嵌套表。
>   >
>   > 
>   >
>   > **Oracle数据类型**
>   >
>   > |      Oracle 内置数据类型       |                             说明                             |
>   > | :----------------------------: | :----------------------------------------------------------: |
>   > |           varchar2()           |         变长字符串，最大长度为4000，PLSQL中为32767字         |
>   > |          nvarchar2()           |                 变长字符串，最大长度32767kb                  |
>   > |              long              |                         变长字符数据                         |
>   > |              Clob              |       字符大型对象，最大长度为(4GB-1) * DB_BLOCK_SIZE        |
>   > |           char(size)           |                   定长字符串，最大为2000B                    |
>   > |          number(p,s)           | 数字类型，p表示精度（1~38）,s 表示小数点右边的数字长度(-84~127)<br />Number(p) ：表示存储总长度为p的整数 <br />Number(p,s) ：表示存储总长度为p的浮点数，小数位长度为s <br /> |
>   > |              date              |                    日期值 yyyy-MM-dd 格式                    |
>   > | timestamp/with Local Time Zone |                   时间戳/ 携带时区的时间戳                   |
>   > |   raw(size)、Long raw(size)    |               原始二进制数据，最大为2000B/2GB                |
>   > |              Blob              |      二进制大型对象，最大存储为(4GB-1) * DB_BLOCK_SIZE       |
>   >
>   > 
>   >
>   > **临时表** （非永久保存，基于session，或一个事务中有效）
>   >
>   > ~~~sql
>   > -- 创建临时表 (数据行只有在当前事务中可见,默认)
>   > CREATE GLOBAL TEMPORARY TABLE  tableName () on commit delete rows;
>   > --  创建临时表 (数据行仅在当前会话中可见)
>   > CREATE GLOBAL TEMPORARY TABLE  tableName () on commit preserve rows;
>   > ~~~
>   >
>   > 
>   >
>   > **索引组织表** （Index Organized Table)
>   >
>   > *区别于表的存储方式（默认堆表，无组织的存储方式，存在可用空间就能存储），IOT表采用B-树索引结构存储表中的索引列（叶子节点存储该行的RowId）*
>   >
>   > 
>   >
>   > **对象表**
>   >
>   > 定义复合型数据类型，供关系表，函数，存储过程使用
>   >
>   > ~~~sql
>   > -- 对象表中不包含  LONG、LONG RAW ROWID 等数据类型
>   > create type PERS_TYP as object (
>   >     COL varchar2,
>   >     COL1 varchar2,
>   >     COL2 date,
>   >     -- 在对象表中定义函数，存储过程(构造方法，类方法，映射方法，排序方法)
>   >     COL3 procedure change_name(params varchar2) is 
>   >      begin 
>   >      ...
>   >     end change_name
>   >      ,
>   >     -- 构造方法
>   >     static function new(...params Type) return 
>   > )
>   > create table t_name(
>   >   COL PERS_TYP,
>   >   COL2 varchar2,
>   >   COL3 varchar3
>   >  )
>   > -- 插入表数据
>   > insert into t_name values ( PERS_TYP('value','value','value'),1234,11);
>   > -- 使用对象表字段
>   > select a.COL.COL from t_name;
>   > ~~~
>   >
>   > **外部表**
>   >
>   > *不存在数据库中的表，通过Oracle数据字典描述外部表数据，外部表的数据只能进行select操作。*
>   >
>   > ~~~sql
>   > -- 创建外部表
>   > create table example ( 
>   >    COL Type 
>   >    ... 
>   > ) ORGANIZATION EXTERNAL (
>   >    TYPE oracle_loader   -- 访问方式     
>   >    DEFAULT DIRECTORY oracle_loader_data_dir  -- 外部文件实际位置
>   >     ACCESS PARAMETERS (     
>   >        RECORDS DELIMITED BY NEWLINE CHARACTERSET US7ASCII  -- 记录用换行符分隔
>   >        SKIP 0 -- 跳过0行
>   >        BADFILE ‘ORACLE_LOADER_BAD_DIR’ : ‘example.bad’ -- 外表的坏文件
>   >        LOGFILE ‘ORACLE_LOADER_LOG_DIR’ : ‘example.log’ -- 外表的日志文件
>   >        FIELDS TERMINATED BY ‘,’ -- 以 , 终止字段，即以 , 分隔字段
>   >        LRTRIM --  删除首尾空白字符
>   >        MISSING FIELD VALUES ARE NULL -- 某些字段空缺值都设为NULL 
>   >        REJECT ROWS WITH ALL NULL FIELDS  ( -- 数据类型装换，与上面表字段名对应
>   >             CREATE_DATE DATE "YYYY/MM/DD HH24:MI:SS",
>   >             GNAME CHAR(200),
>   >        )
>   >     )
>   >    LOCATION (‘1.csv’,‘2.csv’) -- 数据文件名为 ‘1.csv’ 和 ‘2.csv’
>   > )
>   > PARALLEL                   -- 并行处理
>   > REJECT LIMIT UNLIMITED;  -- 读入整个文件
>   > ~~~
>
> - **约束(constraint)**
>
>   > - 空值约束  NOT NULL
>   > - 唯一列值  UNIQUE
>   > - 主键值  PAIMAEY KEY 
>   > - 引用完整值  FOREIGN KEY （外键：通过另一个表约束那些值可以填）
>   > - 复合内联完整性  CHECK (同过表内其他字段来约束该值)
>   > - 基于触发器的完整性
>
> - **索引**
>
>   > - 唯一索引（实现唯一约束）  B-Tree实现
>   > - 非唯一索引（提高查询速度） B-Tree实现
>   > - 反向键索引(减少新增之间数据冲突)
>   > - 基于函数索引（查询列通过函数值创建索引）
>   > - 位图索引（存储索引列每个可能值的位串），位串长度与索引表中行数相同
>
> - **视图** (存储查询)
>
>   > - 普通视图（不存储任何数据）
>   >
>   >   ~~~sql
>   >   create view view_name as SQL with read only;
>   >   ~~~
>   >
>   > - 物化视图（某个时刻的数据副本）
>   >
>   >   > 1. ON DEMAND （需要刷新时，与表数据同步）
>   >   > 2. ON COMMIT（基表提交时，刷新视图）
>   >   >
>   >   > ~~~sql
>   >   > create materialized view my_mv_cd
>   >   > build immediate refresh complete on demand
>   >   > as
>   >   > select p.pid as id, p.name, a.address from test_person p,test_address a
>   >   > where p.pid = a.aid;
>   >   > ~~~
>   
> - **PL/SQL**
>
>   > - 存储过程/函数（用于执行系列的SQL）
>   > - 程序包（函数与存储过程的应用）
>   > - 触发器（基于DML，DDL,数据库事件触发任务）
>
> - **警报和跟踪日志文件** 
>
> - **备份文件**

#### **Oracle系统权限，对象权限**

> 系统权限：允许用户使用数据库权限
>
> **常见系统角色** （创建表、创建索引、连接实例）
>
> 1. DBA：系统最高权限（可以创建数据库，PDB）
> 2. Resource：允许用户创建自己对象（表，索引，存储过程）
> 3. Connect：允许登录Oracle实例，不可以创建实体对象
>
> | 权限编码 （Any可以在任何表空间执行操作） | 权限                   |
> | ---------------------------------------- | ---------------------- |
> | CREATE SESSION                           | 创建会话               |
> | CREATE SEQUENCE                          | 创建序列               |
> | CREATE SYNONYM                           | 创建同名对象           |
> | CREATE TABLE                             | 在用户模式中创建表     |
> | DROP TABLE                               | 删除表                 |
> | CREATE PROCEDURE                         | 创建存储过程           |
> | EXECUTE PROCEDURE                        | 执行任何模式的存储过程 |
> | CREATE USER                              | 创建用户               |
> | DROP USER                                | 删除用户               |
> | CREATE VIEW                              | 创建视图               |
>
> 
>
> ~~~sql
> -- 赋值角色（普通用户授权dba可以拥有system一样权限）
> grant connect, resource, dba to [用户名] [用户名1]
> --  移除dab 角色权限（dba）
> revoke dba from MIAOMIAOLE;
> 
> -- 查看数据库中所有用户（dba）
> select * from dba_users;
> 
> -- 查询系统所有角色（dba）
> select * from dba_roles;
> 
> -- 查询当前用户拥有角色
> select * from dba_role_privs;
> select * from user_role_privs;
> 
> -- 查询系统权限
> select * from DBA_SYS_PRIVS;
> -- 查询用户系统权限
> select * from USER_SYS_PRIVS;
> 
> --  查询当前登录用户所有权限
> select * from session_privs;
> 
> -- 查看当前用户可以看到用户
> select * from all_users;
> 
> -- 查询当前所有用户
> select * from dba_users;
> ~~~
>
> **对象权限** （读取视图，可更新某些列、执行存储过程）
>
> - 对象拥有者拥有对象所有权限
> - 对象拥有者可以向外分配权限
>
> ![image-20230218172843834](img\image-20230218172843834.png) 
>
> ~~~sql
> -- 将object除drop以外所有权限赋值给user
> -- public 表示所有用户
> grant all on object to user  with admin option
> -- 将object权限分配给user with admin option 用于系统权限授权 with grant option 用于对象授权。
> -- with admin option 不会传播（系统管理员将A权限权限收回，不会影响B的权限）
> -- with grant option 具有传播性（收回用户A对象权限，用户B也将收回）
> 
> 
> 
> -- 赋值修改列名对象给用户
> grant update(column) on 表名 to user
> 
> -- 表的访问权限
> select * from TABLE_PRIVILEGES;
> -- 某个角色被赋予的相关表的权限
> select * from  ROLE_TAB_PRIVS;
> 
> select * from ALL_TAB_PRIVS;
> 
> -- 当前用户赋予过的角色（包含系统角色）
> Select * from SESSION_ROLES order by ROLE  
> Select * from USER_ROLE_PRIVS    
> 
> -- User_* 当前拥有的对象信息  ALL_* 当前拥有且授权的对象信息  DBA 所有对象信息
> -- 查询用户所有对象
> SELECT table_name, owner FROM all_tables WHERE owner = 'SCOTT';
> 
> -- 查询并赋值当前用户表权限
> select 'Grant all on '||table_name ||' to COMMON_PDB ;' from all_tables where owner ='MIAOMIAOLE';
> 
> ~~~
>
> **不同用户下访问同一张表解决方案**
>
> - 使用用户名前缀
>
> - 在其他用户中创建视图
>
> - 使用同义词   
>
>   ~~~sql
>   -- 在用户B下使用table_name 代替用户A.table_name
>   create synonym table_name for A.table_name
>   ~~~
>
>   

## RPC

> RPC(Remote Procedure Call Prototcol)允许本地调用方式调用远程服务（通过网络调用两台不同服务器上应用方法）
>
> - 解决通讯问题（TCP,UDP网络连接）
> - 解决寻址问题（基于Web服务调用，或基于RMI注册调用）
> - 数据序列化与反序列化（数据规范）
> - 对调用者透明（解耦服务）

#### **Apache Dubbo （RPC框架）**

> - **单一应用架构**
>
>   > 所有功能集成在一个应用中，减少部署节点和成本，适用于简单的CURD应用，ORM数据访问是关键
>
> - **垂直应用架构**
>
>   > 按业务将功能拆分不同的应用，对比单一应用架构，提升应用效率，提升效率的关键是Web框架
>
> - **分布式服务架构**
>
>   > 基于垂直应用架构，应用之间通信效率为分布式提升效率的关键
>
> - **流动计算架构**
>
>   > 基于访问压力实时管理集群容量，提升集群利用率架构，提高机器利用率的资源调度和**治理中心**(SOA)是关键
>
> **Dubbo架构**
>
> ![image-20220508194507735](img\image-20220508194507735.png) 
>
> - Provider 
> - Consumer
> - Registry
> - Monitor (监控中心，统计应用调用次数和时间)
> - Container （运行容器）
>
> **Dubbo调用流程**
>
> 1. Container启动，加载Provider，并向Registry提供调用接口清单（init）
> 2. Consumer 启动，向Registry订阅**自己所需要**的接口（初始化）
> 3. Registry返回Consumer所需的接口清单，如果有变更（新的Provider加入，或者Provider版本变更），注册中心**主动将变更接口返回给Consumer** （长连接，不用重新建立网络请求）
> 4. **Consumer 使用按照负载均衡算法**，选择一个提供者进行调用（调用失败，则另选）
> 5. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
>
> **注册中心不转发请求**
>
> **注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外**
>
> **注册中心通过长连接感知Provider 是否在线，如果宕机，注册中心将立即推送事件通知消费者，**
>
> **Dubbo服务宕机，不影响以运行的提供者和消费者**
>
> ---
>
> **Dubbo功能**
>
> - 点对点直连服务
> - 服务分组（对远程接口按分组内容调用）
> - 多版本服务（多集群应用下使用版本号作为依据进行调用，通常在集群不停机状态下升级）
> - 分组聚合（类似多线程调用，将Consumer任务分解不同的组，调用时，所有的组进行远程调用，并将最后的结果进行合并）
> - 参数验证
> - 结果缓存
> - 泛化引用，泛化实现
>
> ---
>
> **Dubbo注册中心选择**
>
> - Zookeeper
> - Redis
> - Multicast 
> - 
>
> ---
>
> **Dubbo支持的协议**
>
> - Dubbo 协议 （基于tcp设计，NIO同步非阻塞多路复用）
>
>   > 
>   >
>   > NIO 同步非阻塞（同步：进程等待上一次任务结束后才能执行下一步操作，阻塞：调用进程被中断，调用操作系统进程去执行I/O操作，等待I/O操作执行完后，在唤醒被中断的进程。非阻塞I/O：调用进程不需要等待内核IO操作彻底完成，可立即唤醒当前进程进入就绪态)
>
> - Rmi 协议  可与原生RMI互操作，基于TCP协议
>
>   > `java.rmi.Remote` Java原生实现，使用接口继承Remote实现远程代理对象，实现接口使用UnicastRemoteObject 进行序列化，可以用Spring方式实现
>   >
>   > ~~~java
>   >  //绑定服务接口对象和访问url
>   > LocateRegistry.createRegistry(8080);
>   > Naming.bind("rmi://127.0.0.1:8080/UserService", userServer);
>   >  // 客户端进行访问
>   > UserService userService = (UserService)Naming.lookup("rmi://127.0.0.1:8080/UserService");
>   > 
>   > ~~~
>   >
>   > RMI与Http
>   >
>   > - RMI 在**TCP协议**上传输可序列化Java对象，只能在JVM上使用
>   >
>   > - WebService **基于Http方式进行通讯**
>   >
>   >   > - XML  WebService数据类型
>   >   > - SOAP 用于交换XML编码协议（用于解析XML标记语言规范），可以运行在任何传输协议上
>   >   > - WSDL  WebService描述语言，用于描述Web Service及其函数、参数和返回值
>   >   > - UDDI 
>   >
>   > - RMI性能优于WebService 10倍以上
>   >
>   > - RMI 不能跨语言调用
>
> - Hessian 协议 可与原生Hessian互操作，基于HTTP协议




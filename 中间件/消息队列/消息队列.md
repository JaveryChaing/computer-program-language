## 消息队列

消息队列(MQ)是一种系统间相互协作的通信机制，应用在异步处理，系统解耦，流量削峰，日志收集，事务最终一致性。消息队列的主要组件有Broker（消息处理中心，负责消息的接收，存储，转发），Producer，Consumer。

- #### **AMQP** (Advanced Message Queuing Protocol)  

  > 传输层协议是一个网络级协议，它定义了数据的传输格式，消息队列的客户端可以基于这个协议与消息代理和 AMQP 的相关模型进行交 互通信，该协议的内容包括数据， 吭处理、信道 用、内容编码、心跳检测、数据表示和错误处 理
  >
  > **[AMQP](https://www.amqp.org/) 主要组件**
  >
  > - Message：MQ服务所处理数据单元
  > - Publisher：向交换器发布消息的客户端应用程序
  > - Exchange：接收Publisher发送的消息并将这些消息路由到服务器中的队列
  > - Binding：交换机与消息队列的映射
  > - Broker：消息代理，表示消息队列服务器实体，接受客户端连接，实现 AMQP消息队列和路由功能的过程
  > - Queue：消息容器，也是消息的终点。
  > - Channel：独立的双向数据流通道，建立在TCP通讯上，一个连接可以有多个信道
  > - Consumer
  >
  > 
  >
  > **AMQP消息流转**
  >
  > <img src="img\image-20230102140853342.png" alt="image-20230102140853342" style="zoom:67%;" /> 
  >
  > *Publish发送数据到Broker，Broker中的Exchange根据路由Key与Queue的映射关系（Binding）将消息存储在目标Queue，Consumer向Broker发送订阅消息时指定监听对应Queue，**当Queue中有数据时，Broker主动推送消息到Consumer**。Publish发布消息时可以指定消息属性（routingkey），内容载体对Broker不可见。**Exchange对不能路由的消息返回或丢弃**。单条消息可以被复制到多个Queue中，以广播形式推送给所有的消费者。Queue存在持久化队列和临时消息队列，持久化队列可以被多个消费者共享，不管是否有消费者接收，它都可以独立存在。**临时消费队列只对某个消费者所独有，当消费者断开连接时，消息队列将被删除***
  >
  > 
  >
  > **AMQP消息数据格式**
  >
  > ![image-20230102142832846](img\image-20230102142832846.png) 
  >
  > - 帧头（Header，7字节）
  > - 任意大小负载（payload）
  > - 错误校验帧

- #### **MQTT** (Message Queuing Telemetry Transport 消息队列遥测传输)

  > 轻量、简单、开放和易于实现。应用于很多机器计算能力有限、低带宽、网络不可靠的远程通信应用场景中。
  >
  > 基于MQTT协议实现的中间件服务器有Apache ActiveMQ，RabbitMQ，Apache Apollc，HiveMQ，ThingMQ，VemeMQ。
  >
  >  ![image-20230102144132517](img\image-20230102144132517.png) 
  >
  > 
  >
  > **[MQTT](https://mqtt.org/)组件**
  >
  > - Broker：服务代理
  > - Network Connection：网络连接（使用的底层网络传输协议 TCP/UDP）
  > - Application Message：应用消息，分为主题和负载两部分
  > - Topic：应用消息的类型，由消费者订阅
  > - Payload：负载内容，消费者接收到的内容
  > - Client：包含Publish/Subscriber实现
  > - Server：转发应用消息给客户端，处理客户端连接请求和订阅请求
  > - Session：用于客户端与服务器之间逻辑层面通讯
  > - Subscription：订阅包含一个主题过滤器和Qos服务质量等级。
  > - MQTT Control Packet：网络连接发送的消息数据包
  >
  >  
  >
  > **MQTT数据流转**
  >
  > 1. 建立连接，客户端发送服务器第一个报文必须是CONNECT，服务器发送CONNACK报文响应客户端
  >
  > 2. 发布消息，客户端发送Publish报文，按照QoS等级服务器将发送对应的应答报文
  >
  >    - QoS等级
  >
  >      1. 至多一次(0)：最高的传输性能，接收者不需要应答消息，发送者也不保留消息和重发消息（最多1次通信）
  >
  >      2. 至少一次(1)：消息至少送到到一次（发送者保留消息，直到接收者返回Puback报文，在规定时间内没接收到Puback报文将重新发送此报文，至少2次通信）
  >
  >      3. 只有一次(2)：可保证每条消息只被接收到一次（最慢的服务等级，也是最安全的，至少4次通信）
  >
  >         ![image-20230102153902545](img\image-20230102153902545.png) 
  >
  > 3. 主题订阅，客户端发送Subscribe报文进行注册对应主题（订阅报文中包含订阅者接收到的报文质量等级）
  >
  > 4. 心跳检测，客户端发送PingReq报文给服务器
  >
  >    1. 确认网络连接没有断开
  >    2. 确认服务器，客户端能正常通讯
  >
  >  5. 断开连接，客户端向服务器发送Disconnect报文，表示客户端断开连接
  >
  >    
  >
  > **MQTT数据格式**
  >
  > ![image-20230102152242604](img\image-20230102152242604.png) 
  >
  > 固定报头结构
  >
  > ![image-20230102152327415](img\image-20230102152327415.png) 
  >
  > 4~7比特位表示报文类型
  >
  > ![image-20230102152449211](img\image-20230102152449211.png) 
  >
  > 0~3比特位标识位（无效的标识位将关闭网络连接）
  >
  > ![image-20230102152627699](img\image-20230102152627699.png) 
  >
  > - Publish类型报文标识，用来标识通信质量
  >
  >   - DUP：重发标识，用来保证消息可靠传输。
  >   - Qos：服务质量等级
  >   - Retain：保留表示
  >   - 剩余长度
  >
  
- #### **STOMP**（Streaming Text Orientated Message Protocol 流文本定向消息协议）

  > *提供双向操作的连接格式，允许客户端与任意消息服务进行交互[STOMP](http://stomp.github.io/)*
  >
  > 实现STOMP协议服务组件：Apache Apollo  Apache ActiveMQ，RabbitMQ，HornetQ，StompServer
  >
  > 
  >
  >  **STOMP数据格式**
  >
  > *Command：第一行，以EOL符结束，第二行是帧头，由冒号组成的键值对，以换行符结束，第三行是Body，以特殊字符^@结束*
  >
  > ![image-20230105105007231](img\image-20230105105007231.png) 
  >
  > **Command：**
  >
  > - CONNECT：客户端连接命令
  >
  > - DISCONNECT：客户端断开与服务器连接
  >
  > - SEND：客户端发送消息命令
  >
  >   > ![image-20230105105523655](img\image-20230105105523655.png) 
  >
  > - SUBSCRIBE/UNSUBSCRIBE：客户端订阅某个目的地消息，与Send一样
  >
  >   > ![image-20230105105912216](img\image-20230105105912216.png) ![image-20230105105932064](D:\computer-program-language\中间件\消息队列\img\image-20230105105932064.png) 
  >
  > - BEGIN ：开启事务，用于发送消息和确认已经收到消息（发送与确认被视为原子操作）
  >
  > - COMMIT ：事务提交到处理队列中
  >
  > - ABORT：客户端终止正在执行的事务
  >
  > - ACK：在Client模式下确认收到一个订阅消息
  >
  > - NACK ：客户端返回服务器没处理改消息，服务器将该消息重新发送到另一个客户端或者丢弃
  >
  > - STOMP：客户端以STOMP方式连接服务器
  >
  >   > ![image-20230105105433242](img\image-20230105105433242.png) 
  >
  >   ---
  >
  > - CONNECTED：服务端接收到CONNECT命令后返回CONNECTED帧
  >
  > - MESSAGE：服务器返回客户端订阅消息
  >
  > - RECEIPT：服务器接收到请求后需要告知客户端
  >
  > - ERROR
  >
  >  **Header：**
  >
  > - content-length：标识Body大小
  > - content-type：在Send，Message，Error命令下，描述Body格式，否则将当作二进制数据处理
  > - receipt：除Conntect命令外，然后帧都可以设置该Header，服务器在确认时将会使用RCEIPT 命令来处理。
  
- #### **~~XMPP~~** ~~(可扩展通信与表示协议，基于XML的流式即时通信协议)~~

- #### **JMS** (Java Message Service Java消息服务应用接口)

  > *Java 平台中面向消息中间件的一套规范的JavaAPI接口，类似JDBC由具体厂家实现消息通信*
  >
  > - 点对点模型（Point to Point)
  >
  >   > 应用程序由Queue，Sender，Receive组成，每条消息只有一个接收者，消息发送后，不管接收者是否存在，都会保存到队列中。
  >   >
  >   > ![image-20230105112627657](img\image-20230105112627657.png) 
  >
  > - 发布订阅模型（Pub/Sub)
  >
  >   > 应用程序由Topic，Publish，Subscriber组成，发布者发布消息到主题上传递所有的订阅者（广播）
  >   >
  >   > ![image-20230105112749951](img\image-20230105112749951.png) 
  >
  > **JMS组件**
  >
  > - Producer
  > - Consumer
  > - Client
  > - Queue：消息容器，对应点对点模型中队列
  > - Topic
  > - Message
  >
  > **JMS接口**
  >
  > - ConnectionFactory：创建连接对象，主要实现子类QueueConnectionFactory，TopicConectionFactory
  > - Destination：消息发布或接收地点对象（主题或队列）
  > - Connection：TCP/IP Socket 包装
  > - Session：实际查找消息接口，用于发送接收消息
  > - MessageProducer：消息生产者接口，由Session创建并发送到Destination。分为同步、异步方式发送
  > - MessageConsumer：消息消费者接口，由Session创建。
  > - Message：消息传递对象
  > - MessageListener：消息监听者，监听消息处理事件。
  >
  > **JMS2.0接口**
  >
  > - JMSContext：代替Connection和Session
  > - JMSProducer：代替MessageProducer支持链式操作
  > - JMSConsumer：代替MessageConsumer
  
- #### **RabbitMQ**

  > 基于AMQP标准开发的消息中间件，用于分布式系统中存储转发消息，具有可靠性保证，灵活路由，支持消息集群，具有高可用，支持多种协议（通过插件实现MQTT，STOMP协议），多语言客户端，后台管理页面（MannagementUI），跟踪机制（异常消息排查），插件扩展。
  >
  > ![image-20230105162412557](img\image-20230105162412557.png) 
  >
  > - Message：消息体不透明，消息头包含routing-key，priority，delivery-mode等信息
  >
  > - Publish：客户端应用程序
  >
  > - Exchange：接收客户端发送消息并路由到队列
  >
  >   > - Direct：交换机与队列进行**一对一绑定**，生产者发送数据需要指定交换机
  >   >
  >   > - Topic：交换机可以同时与多个队列绑定，可以通过RouteKey(*，#)决定发送到那些队列。
  >   >
  >   >   生产者发送数据需要指定交换机及主题。
  >   >
  >   > - Fanout：广播到所有队列供多个消费者消费，转发消息最快
  >   >
  >   > - ~~Header~~
  >
  > - Binding：决定交换器被绑定到那个队列上
  >
  > - Queue：保存消息，等待对应的消费者进行消费
  >
  > - Channel：信道，多路复用中单独双向数据流，建立在TCP通信基础上
  >
  > - Broker：RabbitMQ服务器实例
  >
  > 




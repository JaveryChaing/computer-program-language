## Java性能优化

- #### **JVM内存模型**

  > 1. Method Area（方法区，永久区、元空间）
  >
  >    > 存放Class类信息，及常量，静态变量，JDK1.8后使用本地内存存储数据（不需要GC），线程共享。
  >    >
  >    > 变量值存储在方法区中，字符串常量池，静态变量仍在堆中。
  >    >
  >    > 
  >    >
  >    > **类加载器**
  >    >
  >    > - 引导类：负责加载系统类（从JAR文件rt.jar中加载）
  >    >
  >    > - 扩展类：从jre/lib/ext目录加载
  >    >
  >    > - 应用类：由CLASSPATH环境变量中加载类
  >    >
  >    > 委托加载机制（代理模式）：Java虚拟机区分类是否相同通过**类全名和类加载器是否一致**，**保证 Java 核心库的类型安全**（*不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间*）
  >    >
  >    > <img src="..\JavaSE\img\image-20230129095427841.png" alt="image-20230129095427841" style="zoom:67%;" />  <img src="..\JavaSE\img\image-20230129100913237.png" alt="image-20230129100913237" style="zoom:67%;" /> 
  >    >
  >    >   
  >    >
  >    > **Class加载过程**
  >    >
  >    > 加载 →连接（验证，准备，解析） → 初始化
  >    >
  >    > - 加载：读取Class文件将其静态存储结构转换为方法区的运行时数据结构，**并在Heap中生成代表该类的Class对象**
  >    > - 准备：将对象中变量赋予初始值，**及静态变量属性对象创建**
  >    > - 解析：将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量
  >    > - 初始化：执行对象构造方法
  >    >
  >    
  > 2. Heap （堆）
  >
  >    > 运行时数据区，所有类的实例和数组都是在堆上分配内存（由GC进行回收）线程共享
  >    >
  >    > **快速内存分配：**
  >    >
  >    > - 指针碰撞（记入最后一个分配对象地址top，当有新对象分配时，检测top和Eden末端空间是否能容纳新对象空间，则进行开辟空间，top则记录新对象地址）
  >    > - TLAB（线程本地分配缓冲区）：多线程创建对象情况下，每个线程设置缓冲区（Eden中一小块内存，线程在这块内存中创建对象），去除临界资源
  >    >
  >    > **分代收集算法**
  >    >
  >    > 1. Young（1/3）：Eden（4/5），From Survivor （1/10），To Survivor（1/10）：由Minor GC回收
  >    >
  >    >    > Minor GC（标记-复制算法）：Eden空间不足时，触发GC（扫描Eden+From Survivor区域）将存活的对象复制到To Survivor区域中（To Survivor此时为空），同时清空Eden，FromSurvivor区域。From Survivor与 To Survivor角色互换，下次GC时将作为存活对象容器。
  >    >    >
  >    >    > 当From Survivor 与 To Survivior 交换超过15次时（MaxTenuringThreshold），To Survivor中存活对象将复制到Old区，Minor GC存在STW
  >    >
  >    > 2. Old（2/3)：由Major GC回收
  >    >
  >    >    > Major GC 触发机制：
  >    >    >
  >    >    > - Old 空间不足
  >    >    > - To Survivor，Eden（超大对象） 复制到Old区空间不足
  >    >    >
  >    >    > 
  >    >    >
  >    >    > Full GC：Marjor GC与 Minor GC组合过程，清理Young与Old对象，通常与Marjor GC等价
  >    >    >
  >    >    > - System.gc()
  >    >    > - Minor GC 存活的对象大小超过了老年代剩余空间
  >    >    >
  >    >    > 
  >    >    >
  >    >    > **Major GC:** 
  >    >    >
  >    >    > - **Serial：串行垃圾收集器**
  >    >    >
  >    >    >   > 基于标记-压缩算法实现
  >    >    >   >
  >    >    >   > 标记-压缩：将标记对象清除，将存活对象向堆头部移动，将可用堆空间连续
  >    >    >
  >    >    > - **Parallel：并行垃圾回收器**
  >    >    >
  >    >    >   - **CMS(Concurrent Mark Sweep)：获取最短回收停顿时间为目标的收集器**
  >    >    >
  >    >    >     > 基于标记-清除算法实现（存在内存碎片）
  >    >    >     >
  >    >    >     > - 初始标记：SWT后，选举出GCRoots
  >    >    >     > - 并发标记：开启GC线程（不影响用户线程），对Roots进行引用分析并进行标记
  >    >    >     > - **重新标记：SATB漏标对象分析（修正并发期间其他线程创建对象引用分析，耗时长，且SWT）**
  >    >    >     > - 并发清除： GC 线程开始对未标记的区域做清扫
  >    >    >     >
  >    >    >     > <img src="img\image-20230208150412799.png" alt="image-20230208150412799" style="zoom:67%;" /> 
  >    >    >     >
  >    >    >     > -  对CPU资源敏感
  >    >    >     >
  >    >    >     > - 无法处理GC线程带来的浮动垃圾
  >    >    >     > - 标记清除算法存在内存碎片
  >    >    >     > - 并发收集，低停顿（用户线程与GC 线程并发执行）
  >    >    >     >
  >    >    >     > -XX:+UserConcurrentMarkSweepGC
  >    >    >
  >    >    >   - **G1(Garbage-First)分代分布并行收集器**  
  >    >    >
  >    >    >     > Region：将Java堆等大分区（分区大小范围为2的幂1,2,4,8,16,32） -XX:G1HeapRegionSize控制分区大小
  >    >    >     >
  >    >    >     > Region种类：可用区，Eden，Survivor，**Humongous（超大对象分区，当一个对象大小超过分区一半时定义为巨型对象，巨型对象被归纳到Old区，且一定是连续分配的，分配后不会移动）**，Old
  >    >    >     >
  >    >    >     > Rsets：记录并跟踪其它Region指向该Region中对象的引用
  >    >    >     >
  >    >    >     > CSets：一组可被回收的分区集合
  >    >    >     >
  >    >    >     > Card Table：Region中内部位置，供Rset记录
  >    >    >     >
  >    >    >     > <img src="img\image-20230208160331117.png" alt="image-20230208160331117" style="zoom:67%;" /> 
  >    >    >     >
  >    >    >     > **Young GC：Eden分区数量达到上限时触发（SWT），将Eden中数据复制到to Survivor或Old区中，同时清空所有Eden区数据**
  >    >    >     >
  >    >    >     > [Young GC 过程](https://cloud.tencent.com/developer/article/1824886)
  >    >    >     >
  >    >    >     > 
  >    >    >     >
  >    >    >     > **Mixed GC：**（Survivor+部分Old区）
  >    >    >     >
  >    >    >     > - 全局并发标记
  >    >    >     >   1. 初始：标记一下GC Roots能直接关联到的对象（所有线程暂停）
  >    >    >     >   2. 根区域扫描：GC Root开始对堆中对象进行可达性分析（SATB解决并发时漏标，耗时长）
  >    >    >     > - 拷贝存活对象
  >    >    >     >
  >    >    >     > 
  >    >    >     >
  >    >    >     > G1使用场景：
  >    >    >     >
  >    >    >     > - XX:MaxGCPauseMillis=200 （控制G1回收垃圾时间） 
  >    >    >     >
  >    >    >     > - 实时数据占用超过一半的堆空间
  >    >    >     >
  >    >    >     > - 对象分配或者晋升的速度变化大
  >    >    >     >
  >    >    >     > - 希望消除长时间的GC停顿（超过0.5-1秒）
  >    >    >     >
  >    >    >     > -XX:+UseG1GC
  >    >    >
  >    >    >   - **[ZGC](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)**
  >    >    >
  >    >
  >    > **三色标记法**
  >    >
  >    > - 白色：表示对象尚未被GC访问过，GC开始标记时所有对象都为白色
  >    > - 黑色：该对象及该对象所有引用都被GC访问过
  >    > - 灰色：该对象被GC访问过，其引用对象存在至少存在一个引用未被GC访问
  >    >
  >    > 三色标记遍历过程：
  >    >
  >    > 1. 初始时，对象都为白色
  >    > 2. 选举出GC Roots节点，其对象标记灰色
  >    > 3. 访问灰色对象的引用对象，将其标记为黑色，
  >    > 4. 重复3步骤直到Roots节点都变为黑色
  >    > 5. 扫描结束后，标记为白色的对象为回收对象
  >    >
  >    > 多标（浮动垃圾）：多线程情况下对象引用断开，导致存在垃圾对象被标记为黑色（需要下一轮GC才被回收）
  >    >
  >    > 漏标：多线程情况下灰色对象断开白色对象引用，白色对象被GC，后续存在其他对象黑色对象引用（导致程序不能运行）
  >    >
  >    > **写屏障：** 当对象引用发送变化时，将原来成员变量的引用记入下来
  >    >
  >    > **SATB：** 在初始标记时生成快照图，标记存活对象，并发标记时出现引用更改会将原来值记录在日志（并发情况下）
  >    >
  >    > CMS：写屏障+增量更新
  >    >
  >    > G1：写屏障+STAB
  >    >
  >    > ---
  >    >
  >    > 堆内存分配：指针碰撞分配，使用空闲表记录未使用内存地址
  >    >
  >    > **对象内存结构：**
  >    >
  >    > 1. 对象头（hashCode，GC分代年龄，锁状态标志，线程持有锁，偏向线程ID）
  >    > 2. 实例数据
  >    > 3. 对齐填充
  >    >
  >    > ---
  >    >
  >    > 堆溢出：虚拟机内存不够，JVM无法申请新内存空间
  >    >
  >    > 堆泄漏：对象不在使用，GC无法收回
  >    >
  >    > ---
  >    >
  >    > 
  >    >
  >    > **Java引用类型**
  >    >
  >    > - StrongReference：
  >    >
  >    >   > 非null变量赋值都是强引用，GC线程永远不会对其进行回收
  >    >
  >    > - SoftReference：
  >    >
  >    >   > 使用`new SoftReference<>(Obj)`包装的对象，JVM内存不足，且发生GC时，Obj将被回收，
  >    >   >
  >    >   > 适合缓存对象的设计。
  >    >
  >    > - WeakReference：
  >    >
  >    >   > 使用`new WeakReference<>(Obj)`包装的对象，当发生GC时，Obj将被回收
  >    >   >
  >    >   > LocalThread中存在使用
  >    >
  >    > - PhantomReference：
  >    >
  >    > *当JVM中垃圾收集时，GC发现referent为弱可达，那么GC将referent引用对象挂载到GC回收链表上，并发生一次线程通信，通知ReferenceHandler线程取走这些引用对象做后续处理，ReferenceHandler 判断时Cleaner实例，调用clean清理释放资资源，对于PhantomReference类型，需要放入ReferenceQueue队列，等待系统资源释放后删除。对于FinalReference，也几乎没有直接使用该类的，而都是直接使用其子类java.lang.ref.Finalizer，在队列中会发生第二次线程间通信，ReferenceHandler线程在将Reference对象入队列时，会通知FinalizerThread做进一步的处理——即调用FinalReference封装的referent重写的java.lang.Object的finalize()方法*
  >
  > 3. VM Stack（虚拟机栈）
  >
  >    > Java方法调用栈，线程私有的（生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡）。
  >    >
  >    > **`StackOverFlowError`：** 若栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 `StackOverFlowError` 错误。
  >    >
  >    > **`OutOfMemoryError`：** 如果栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出`OutOfMemoryError`异常。
  >
  > 4. Native Method Stack（本地方法栈）
  >
  > 5. Program Count Register（程序计数器）
  >
  >    > 负责记录执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能
  >
  > **JVM重要参数**
  >
  > - -Xms <size> [unit]：JVM分配最小堆空间
  >
  > - -Xmx <size> [unit]：JVM分配最大堆空间
  >
  > - -XX:NewSize= <young size> [unit] ：Young 空间大小
  >
  > - -XX:MAXNewSize= <young size> [unit]：Young 最大空间
  >
  > - -XX:+UseSerialGC：串行垃圾收集器
  >   -XX:+UseParallelGC：并行垃圾收集器
  >   -XX:+UseParNewGC：CMS 垃圾收集器
  >   -XX:+UseG1GC：G1 垃圾收集器
  >
  > - GC日志
  >
  >   ~~~sh
  >   # 必选
  >   # 打印基本 GC 信息
  >   -XX:+PrintGCDetails
  >   -XX:+PrintGCDateStamps
  >   # 打印对象分布
  >   -XX:+PrintTenuringDistribution
  >   # 打印堆数据
  >   -XX:+PrintHeapAtGC
  >   # 打印Reference处理信息
  >   # 强引用/弱引用/软引用/虚引用/finalize 相关的方法
  >   -XX:+PrintReferenceGC
  >   # 打印STW时间
  >   -XX:+PrintGCApplicationStoppedTime
  >
  >   # 可选
  >   # 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint
  >   -XX:+PrintSafepointStatistics
  >   -XX:PrintSafepointStatisticsCount=1
  >
  >   # GC日志输出的文件路径
  >   -Xloggc:/path/to/gc-%t.log
  >   # 开启日志文件分割
  >   -XX:+UseGCLogFileRotation
  >   # 最多分割几个文件，超过之后从头文件开始写
  >   -XX:NumberOfGCLogFiles=14
  >   # 每个文件上限大小，超过就触发分割
  >   -XX:GCLogFileSize=50M
  >
  >   ~~~
  >
  > - OOM内存快照
  >
  >   ~~~sh
  >   # 指示 JVM 在遇到 OutOfMemoryError 错误时将 heap 转储到物理文件中。
  >   -XX:+HeapDumpOnOutOfMemoryError
  >   -XX:HeapDumpPath=./java_pid<pid>.hprof
  >   # 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 cmd args 空间中使用适当的命令
  >   -XX:OnOutOfMemoryError="< cmd args >;< cmd args >"
  >   # 它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例
  >   -XX:+UseGCOverheadLimit
  >   ~~~
  >
  > **JDK监控和故障处理工具**
  >
  > - jps 
  >
  > - **jstat** -<option> [-t] [-h] <vmid> [ interval] [count] ：用于收集 HotSpot 虚拟机各方面的运行数据
  >
  >   > **jstat -gcutil <pid> 1000 5** ：查看pid 内存区域使用情况及GC次数，耗时
  >   >
  >   > ![image-20230209142604954](img\image-20230209142604954.png) 
  >   >
  >   > S0、S1：表示Survival使用率
  >   >
  >   > E：Eden使用率
  >   >
  >   > O：老年代使用率
  >   >
  >   > M：元空间使用率（动态）
  >   >
  >   > YGC：YounGC的总次数
  >   >
  >   > YGCT：表示 YoungGC的总耗时(秒)
  >   >
  >   > FGC：表示 FullGC的次数
  >   >
  >   > FGCT：表示 FullGC的总耗时(秒)
  >   >
  >   >  
  >   >
  >   > **jstat -class vmid **：展示类加载情况
  >   >
  >   > **jstat  -gc vmid** ： 显示与 GC 相关的堆信息
  >
  > - **jinfo -flag [+ | -] name vmid ：在不重启JVM情况下动态修改JVM参数**
  >
  >   > ~~~sh
  >   > // -XX:-PrintGC 取消GC日志打印
  >   > jinfo  -flag  PrintGC 17340
  >   > jinfo  -flag  +PrintGC 17340
  >   > ~~~
  >
  > - **jmap：生成堆转储快照 dump**
  >
  >   > jmap -histo:live <pid> 触发GC 并生成dump文件
  >   >
  >   > <img src="img\image-20230214164624317.png" alt="image-20230214164624317" style="zoom: 67%;" />  
  >
  > - **jstack：生成虚拟机当前时刻的线程快照**
  >
  > - **jhat：分析dump文件，并可以在浏览器访问分析结果**
  >
  >   > jhat -port 5000 heap.hrof ：使用5000端口查看heap文件
  >
  > 

- #### **性能指标**

  1. 预期吞吐量
  2. 请求和响应预期延迟
  3. 支持并发用户或并发任务
  4. 并发任务最大时，可接受的吞吐量与延迟
  5. 最差情况延迟
  6. 垃圾收集延迟范围及频率

- #### **性能分析**

  - 直顶向下

    > 监测应用负载情况，检查应用配置变化。在特定负载场景下对应用进行监控，监控范围包括操作系统，Java虚拟机，JavaEE容器。通常需要更改代码配置（JVM垃圾回收调优，JVM命令行选项调优，操作系统调优，第三方库和Java代码调优）
  
  - 直底向上
  
    > 根据计算机资源环境进行应用调优（CPU数量，架构，内存）。需要收集和监控CPU性能统计数据（CPU高速缓存命中率，执行应用所需指令及扩展指令）。主要是改善CPU使用率，一般涉及汇编，编译器优化。不涉及应用源码。
  
- #### **操作系统性能指标**

  - CPU使用率

    > 1. 用户态使用率（应用程序占用CPU时间与总时间百分比）
    > 2. 系统态使用率（操作系统占用CPU时间与总时间百分比）
    >
    > - **系统态占用高场景：共享资源存在竞争或IO设备之间有大量交互，提高应用性能和扩展一个目标是尽可能降低系统态CPU使用率**

  - IPC（时钟指令数）/ CPI（每指令时钟周期）

    > CPU等待内存数据中所消耗时间（停滞）会统计到CPU使用率中（通常指令未命中需要浪费好几百个时钟周期）。**提高计算密集型应用性能策略是减少停滞或改善CPU高速缓存使用率**

  - CPU调度程序运行队列
  
    > 运行队列：已就绪进程，正等待CPU资源运行。
    >
    > **运行队列长度长时间超过处理器数量的3~4倍需要排查问题**
    >
    > 1. 增加CPU减少处理器负载量
    > 2. 改进CPU使用率（减少应用运行所需要CPU周期时间，数据结构及算法改进）
  
  - 内存使用率
  
    > 页中断（页置换）：影响应用吞吐率及响应时间（JVM垃圾收集器在页面交换时会停止所有正在运行的应用线程）  
  
  - 进程上下文切换（锁竞争）
  
    > 任务中断带来的CPU开销（根据任务优先级对正在处理的任务中断而执行其他任务，后续返回该任务继续执行）
    >
    > 让步式上下文切换：执行线程主动释放CPU资源
    >
    > 抢占式上下文切换：线程因分配的时间片用尽被迫放弃CPU资源或让其他更高级的线程所抢占
    
  - 网络IO使用率
  
  ---
  
- #### **Java应用性能分析**

  > ![image-20230214155727445](img\image-20230214155727445.png) 
  >
  > 应用系统需求
  >
  > - 可用性（99.999%可用，一年宕机不超过5分15秒）
  >
  > - 可管理性（应用迭代，产品发布）
  >
  > - 吞吐量（单位时间内处理工作量，每秒请求/每秒并发/每秒事务）
  >
  > - 延迟及响应性（应用收到指令开始工作到工作完成所耗费时间）
  >
  > - 内存占用（增大内存可用提高吞吐量，降低延迟，但成本上升）
  >
  > - 程序热区优化（应用启动时间降低）
  >
  >   > -server-XX:+TieredCompilation
  >   >
  >   > -client-XX:
  >
  > **GC日志及调优**
  >
  > - Minor GC 尽可能多收集垃圾对象（GC算法提升）
  >
  >   > CMS优化方向：
  >   >
  >   > 1. 控制新生代到老年代速率（-XX:MaxTenuringThreshold 参数控制默认15，设置Survivor空间大小）
  >   > 2. 并行老年代收回空间速率
  >   > 3. 老年代空间碎片
  >   > 4. 减少CMS停顿时间（-XX:+CMSScavengeBeforeRemark (CMS重新标记前进行一次MinorGC，减少老年代新增对象数目)
  >
  > - Java堆空间越大，吞吐量高，延迟低（内存成本）
  >
  > - 确定内存使用（确定活跃数据大小，FullGC后Java堆占用的空间）
  >
  >   > 减少GC次数有利于降低程序延迟
  >   >
  >   > 1. -Xms，-Xmx 设置老年代FullGC后的3~4倍
  >   >
  >   > 2. -Xmn 设置老年代FullGC后的1~1.5倍
  >   >
  >   > 3. MinorGC时间过长（减少Xmn空间）MinorGC频率过高（新增Xmn空间）
  >   > 4. 新生代空间至少为Java堆大小的10%，老年代空间不小于活跃数据的1.5倍
  >
  > **逃逸分析（Escape Analysis）**
  >
  > > 评估Java对象可见范围技术。
  > >
  > > 逃逸：由某个线程创建的对象在另一个线程中可以访问，该对象称之为逃逸（若Java对象不在逃逸，则可以用其他方法进行优化）一般对象被全局引用或外部使用肯定存在逃逸。
  > >
  > > -XX:+DoEscapeAnalysis  开启逃逸分析
  > >
  > > -XX:+PrintEscapeAnalysis 查看逃逸分析结果
  > >
  > >   
  > >
  > > JVM逃逸优化：
  > >
  > > 1. 同步消除（消除对象锁提高性能）
  > > 2. 标量替换（将对象属性分解为基本数据类型进行读取）
  > > 3. 栈上分配（对象发送标量替换，则对象成员将分配到线程栈使用，不需在堆上分配）
  
- #### **Web Service 性能**

  > 线程池配置
  >
  > | 属性       | 描述          |
  > | ---------- | ------------- |
  > | 初始线程数 | 硬件线程数    |
  > | 线程数     | 2* 硬件线程数 |
  >
  > - **Http压缩**
  > - **内容缓存**
  > - **Http服务器文件缓存**
  > - **会话持久**
  >
  > 
  
- #### **监测工具**

  **Linux命令行监控**

  > - **vmstat  3  10  （以3秒为时间间隔，连续收集10次性能数据）**
  >
  >   ![image-20230130105712098](img\image-20230130105712098.png) 
  >
  >   1. r：运行队列中等待进程数
  >   2. b：在等待IO的进程数
  >   3. swpd：已使用的交换内存（kb）
  >   4. free：空闲的物理内存（kb）
  >   5. buff：内存写入到硬盘中间数据（内存不足时指标过高）
  >   6. cache：用作高数缓存的内存数（提高CPU执行效率）
  >   7. si：从磁盘读取到内存页数（缺页次数，内存不足时指标高）
  >   8. so：从内存交换到磁盘的页数（缺页次数，内存不足时指标高）
  >   9. bi：读取磁盘块数
  >   10. bo：写入磁盘快数
  >   11. in：中断次数
  >   12. cs：每秒上下文切换次数
  >   13. us：用户态使用率
  >   14. sy：系统态使用率
  >   15. id：空闲CPU使用率
  >   16. wa：等待IO消耗CPU时间
  >   17. st：从虚拟设备中获取的时间
  >
  > - **pidstat  -w （每秒输出所有虚拟处理器上下文切换）**  
  >
  >   ![image-20230130150401070](img\image-20230130150401070.png) 
  >
  >   1. cswch/s ：每秒主动任务上下文切换数量
  >   2. nvcswch/s：每秒被动任务上下文切换数量
  >
  >   | 参数       | 说明                                     |
  >   | ---------- | ---------------------------------------- |
  >   | -u（默认） | 显示各个进程的cpu使用统计                |
  >   | -r         | 显示各个进程的内存使用统计               |
  >   | -d         | 显示各个进程的IO使用情况                 |
  >   | -p         | 指定进程号                               |
  >   | -w         | 显示每个进程的上下文切换情况             |
  >   | -t         | 显示选择任务的线程的统计信息外的额外信息 |
  >   | -I         | 在SMP环境，表示任务的CPU使用率/内核数量  |
  >
  > - **netstat （监测网络I/O使用情况）**
  >
  >   | 参数          | 说明                                            |
  >   | ------------- | ----------------------------------------------- |
  >   | **-a**        | **显示所有网络连接和监听的所有端口 （Socket）** |
  >   | -A <网络类型> | 列出该网络类型连线中的相关地址                  |
  >   | -c            | 持续列出网络状态                                |
  >   | -C  / --cache | 显示路由器配置的快取信息                        |
  >   | -g            | 显示多重广播功能群组组员名单                    |
  >   | -i            | 显示网络界面信息表单                            |
  >   | **-l**        | **显示监控中的服务器的Socket**                  |
  >   | **-n**        | **直接使用ip地址，而不通过域名服务器**          |
  >   | -N            | 显示网络硬件外围设备的符号连接名称              |
  >   | **-p**        | **显示正在使用Socket的程序识别码和程序名称**    |
  >   | -r            | 显示Routing Table                               |
  >   | **-s**        | **显示网络工作信息统计表**                      |
  >   | **-t**        | **显示TCP传输协议的连线状况**                   |
  >   | -u            | 显示UDP传输协议的连线状况                       |
  >
  >   ![image-20230130153051181](img\image-20230130153051181.png) 




​     

​    

​    

​    

​    


​    

​    

​    


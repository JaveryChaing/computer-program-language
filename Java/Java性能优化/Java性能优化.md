## Java性能优化

- #### 性能指标

  1. 预期吞吐量
  2. 请求和响应预期延迟
  3. 支持并发用户或并发任务
  4. 并发任务最大时，可接受的吞吐量与延迟
  5. 最差情况延迟
  6. 垃圾收集延迟范围及频率

- #### **性能分析**

  - 直顶向下

    > 监测应用负载情况，检查应用配置变化。在特定负载场景下对应用进行监控，监控范围包括操作系统，Java虚拟机，JavaEE容器。通常需要更改代码配置（JVM垃圾回收调优，JVM命令行选项调优，操作系统调优，第三方库和Java代码调优）
  
  - 直底向上
  
    > 根据计算机资源环境进行应用调优（CPU数量，架构，内存）。需要收集和监控CPU性能统计数据（CPU高速缓存命中率，执行应用所需指令及扩展指令）。主要是改善CPU使用率，一般涉及汇编，编译器优化。不涉及应用源码。
  
- #### **操作系统性能分析**

  - CPU使用率

    > 1. 用户态使用率（应用程序占用CPU时间与总时间百分比）
    > 2. 系统态使用率（操作系统占用CPU时间与总时间百分比）
    >
    > - **系统态占用高场景：共享资源存在竞争或IO设备之间有大量交互，提高应用性能和扩展一个目标是尽可能降低系统态CPU使用率**

  - IPC（时钟指令数）/ CPI（每指令时钟周期）

    > CPU等待内存数据中所消耗时间（停滞）会统计到CPU使用率中（通常指令未命中需要浪费好几百个时钟周期）。**提高计算密集型应用性能策略是减少停滞或改善CPU高速缓存使用率**

  - CPU调度程序运行队列
  
    > 运行队列：已就绪进程，正等待CPU资源运行。
    >
    > **运行队列长度长时间超过处理器数量的3~4倍需要排查问题**
    >
    > 1. 增加CPU减少处理器负载量
    > 2. 改进CPU使用率（减少应用运行所需要
  
    
  
  - **Linux命令行监控**
  
    - vmstat  3  10  （以3秒为时间间隔，连续收集10次性能数据）
  
      ![image-20230130105712098](img\image-20230130105712098.png) 
  
      1. r：运行队列中等待进程数
      2. b：在等待IO的进程数
      3. swpd：已使用的交换内存（kb）
      4. free：空闲的物理内存（kb）
      5. buff：内存写入到硬盘中间数据（内存不足时指标过高）
      6. cache：用作高数缓存的内存数（提高CPU执行效率）
      7. si：从磁盘读取到内存页数（缺页次数，内存不足时指标高）
      8. so：从内存交换到磁盘的页数（缺页次数，内存不足时指标高）
      9. bi：读取磁盘块数
      10. bo：写入磁盘快数
      11. in：中断次数
      12. cs：每秒上下文切换次数
      13. us：用户态使用率
      14. sy：系统态使用率
      15. id：空闲CPU使用率
      16. wa：等待IO消耗CPU时间
      17. st：从虚拟设备中获取的时间
  
      ---
  
  - 

​    


​    

​    

​    

